/* tslint:disable */
/* eslint-disable */
/**
 * Devhooks API
 *  ## About Create stateful HTTP endpoints that can dynamically respond to inbound requests based on request matching, invocation count, and response rules.   Requests are stored in sequence for application debugging and analysis.  ## Use cases - Test webhook integrations with mockable responses, delays, and exceptions. - If your application sends data to other services (via Webhooks) mock external server behaviour and verify you application\'s behaviour.  ## Alternatives One can mock HTTP calls in unit tests but testing external URLs in smoketests or integration suites is difficult. There are existing mock server projects that can be deployed in containers but project setup and DNS routing is a barrier.  ## Future support - Additional protocols such as MQTT (IOT), SMS, Email, FTP, SMTP, and more. - Scripting for serverless lambdas without AWS or bundling. - Market place for common actions such as \"Notify slack\", \"Send me an SMS\", \"Send me an email\" - Tracking applications using the request history         
 *
 * The version of the OpenAPI document: 0.0.1-ALPHA
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import {
    SMSDto,
    SMSDtoFromJSON,
    SMSDtoToJSON,
} from '../models';

export interface GetSMSRequest {
    since: Date;
    from?: string;
    timeout?: number;
    minCount?: number;
}

/**
 * 
 */
export class SmsControllerApi extends runtime.BaseAPI {

    /**
     * Get SMS message
     */
    async getSMSRaw(requestParameters: GetSMSRequest): Promise<runtime.ApiResponse<Array<SMSDto>>> {
        if (requestParameters.since === null || requestParameters.since === undefined) {
            throw new runtime.RequiredError('since','Required parameter requestParameters.since was null or undefined when calling getSMS.');
        }

        const queryParameters: any = {};

        if (requestParameters.since !== undefined) {
            queryParameters['since'] = (requestParameters.since as any).toISOString();
        }

        if (requestParameters.from !== undefined) {
            queryParameters['from'] = requestParameters.from;
        }

        if (requestParameters.timeout !== undefined) {
            queryParameters['timeout'] = requestParameters.timeout;
        }

        if (requestParameters.minCount !== undefined) {
            queryParameters['minCount'] = requestParameters.minCount;
        }

        const headerParameters: runtime.HTTPHeaders = {};

        const response = await this.request({
            path: `/sms`,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        });

        return new runtime.JSONApiResponse(response, (jsonValue) => jsonValue.map(SMSDtoFromJSON));
    }

    /**
     * Get SMS message
     */
    async getSMS(requestParameters: GetSMSRequest): Promise<Array<SMSDto>> {
        const response = await this.getSMSRaw(requestParameters);
        return await response.value();
    }

}
