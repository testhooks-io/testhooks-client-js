/* tslint:disable */
/* eslint-disable */
/**
 * Devhooks API
 *  ## About Create stateful HTTP endpoints that can dynamically respond to inbound requests based on request matching, invocation count, and response rules.   Requests are stored in sequence for application debugging and analysis.  ## Use cases - Test webhook integrations with mockable responses, delays, and exceptions. - If your application sends data to other services (via Webhooks) mock external server behaviour and verify you application\'s behaviour.  ## Alternatives One can mock HTTP calls in unit tests but testing external URLs in smoketests or integration suites is difficult. There are existing mock server projects that can be deployed in containers but project setup and DNS routing is a barrier.  ## Future support - Additional protocols such as MQTT (IOT), SMS, Email, FTP, SMTP, and more. - Scripting for serverless lambdas without AWS or bundling. - Market place for common actions such as \"Notify slack\", \"Send me an SMS\", \"Send me an email\" - Tracking applications using the request history         
 *
 * The version of the OpenAPI document: 0.0.1-ALPHA
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { exists, mapValues } from '../runtime';
import {
    RequestPattern,
    RequestPatternFromJSON,
    RequestPatternFromJSONTyped,
    RequestPatternToJSON,
    ResponseRule,
    ResponseRuleFromJSON,
    ResponseRuleFromJSONTyped,
    ResponseRuleToJSON,
} from './';

/**
 * 
 * @export
 * @interface CreateRulesetOptions
 */
export interface CreateRulesetOptions {
    /**
     * 
     * @type {string}
     * @memberof CreateRulesetOptions
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRulesetOptions
     */
    description?: string;
    /**
     * 
     * @type {string}
     * @memberof CreateRulesetOptions
     */
    strategy?: CreateRulesetOptionsStrategyEnum;
    /**
     * 
     * @type {Array<ResponseRule>}
     * @memberof CreateRulesetOptions
     */
    responses?: Array<ResponseRule>;
    /**
     * 
     * @type {Array<RequestPattern>}
     * @memberof CreateRulesetOptions
     */
    requestPatterns?: Array<RequestPattern>;
}

/**
* @export
* @enum {string}
*/
export enum CreateRulesetOptionsStrategyEnum {
    SINGULAR = 'SINGULAR',
    SEQUENTIAL_LOOP = 'SEQUENTIAL_LOOP',
    SEQUENTIAL_ONCE = 'SEQUENTIAL_ONCE',
    RANDOM_SELECTION = 'RANDOM_SELECTION'
}

export function CreateRulesetOptionsFromJSON(json: any): CreateRulesetOptions {
    return CreateRulesetOptionsFromJSONTyped(json, false);
}

export function CreateRulesetOptionsFromJSONTyped(json: any, ignoreDiscriminator: boolean): CreateRulesetOptions {
    if ((json === undefined) || (json === null)) {
        return json;
    }
    return {
        
        'name': !exists(json, 'name') ? undefined : json['name'],
        'description': !exists(json, 'description') ? undefined : json['description'],
        'strategy': !exists(json, 'strategy') ? undefined : json['strategy'],
        'responses': !exists(json, 'responses') ? undefined : ((json['responses'] as Array<any>).map(ResponseRuleFromJSON)),
        'requestPatterns': !exists(json, 'requestPatterns') ? undefined : ((json['requestPatterns'] as Array<any>).map(RequestPatternFromJSON)),
    };
}

export function CreateRulesetOptionsToJSON(value?: CreateRulesetOptions | null): any {
    if (value === undefined) {
        return undefined;
    }
    if (value === null) {
        return null;
    }
    return {
        
        'name': value.name,
        'description': value.description,
        'strategy': value.strategy,
        'responses': value.responses === undefined ? undefined : ((value.responses as Array<any>).map(ResponseRuleToJSON)),
        'requestPatterns': value.requestPatterns === undefined ? undefined : ((value.requestPatterns as Array<any>).map(RequestPatternToJSON)),
    };
}


